## Setup
-> Download Forge Mod Development Kid
-> Copy files from FMDK to project folder:
	- $ cp -R mkd/gradle/ <p_folder>
	- $ cp -R mdk/src/ <p_folder>
	- $ cp mdk/gradlew* <p_folder>
	- $ cp mdk/gradle.properties <p_folder>
	- $ cp mdk/build.gradle <p_folder>
-> Import gradle project in SDK
-> Set Project SDK 17 as Project SDK
-> Edit build.gradle 
	- version
	- group
	- archiveBaseName
	
	// build gradle relevant info
	
	minecraft { mappings } -> allows for replace obfuscated minecraft src names to human legible ones

	run { client sever data } -> run configurations to run minecraft from IDE

	repositories, dependencies -> repositories and dependencies for the project
-> Add useful dependencies to the gradle
	- JEI
	- TOP
-> Edit gradle.properties to set JEI Version
-> Go to gradle tasks and in foregradle runs use genIntelijRuns to generate the run client
-> Press the refresh button to refresh the project and apply changes
-> Set the run configuration to client and press the play button to run minecraft with our mod loaded
-> If minecraft launched project setup is ready and we can start developing

## Mod Init
-> Rename the mod package and mod ID
-> Any change done in the mod name and id must be changed in meta-inf/mods.toml
-> Create a setup package and classes for clientsetup, modsetup and registration
-> In the main mod class register event listeners for the clientsetup and modsetup and add a call for registration-> Note that the registration happens before the modloadingevent is launched, so we must call the registration before the modsetup and clientsetup events are fired
-> In the registration package we must create a deferred register for blocks and items and add all the blocks and items that we want our mod to have to them, after that, in the init funcion, we add the deferred registers to the mod event bus
-> In order to create the assets needed for the mod we have to create a folder /resources/assets/modname/textures/block. For this textures, sounds etc to be loaded into minecraft we have to create a json, and instead of doing it manually we create a datagenerator package.
-> In the datagen package we will need to override all minecraft resource loading functions. We will need
	- DataGenerators Class -> allows us to gather data from other datagenerator classes and subscribe it to the forge event bus. 
	-----------------------------------------------------------------
	- ModBlocksTags -> adds tags to the blocks in the generator (ie: canSpawnMobs, isMinable, requiresIronPick...)
	- ModBlockState -> adds states to the blocks
	- ModItemModels -> retrieves from resources the models for the items
	- ModItemTags -> add tags to the items in the generator (ie: ore, chest...)
	- ModLanguageProvider -> adds locale friendly items name and text
	- ModLootTable -> creates the loot table associating what item drops each block
	- ModRecipes -> creates the recipe table
-> The datageneration will happen whenever we call for the run configuration data gen, this will generate the assets for our mod. This configuration is in minecraft/runs/data in the gradle file (Remember any change done to this will need for the gradle to re-generate the run configurations)
-> Note that the file name for the textures in /resources/assets/modname/block must match the name indicated in the Register when creating the RegistryObject for the DeferredRegisters

## Add Item Workflow
-> Create the item inside setup/register
-> Add the item texture to /resources/assets/tutorialmod/textures
-> Add the localization in /datagen/ModLanguageProvider
-> Set the model path (inheriting or new) in /datagen/ModItemModels
-> Set the tag in /datagen/ModItemTags
-> Set the recipe or loot if needed in ModLootTable and ModRecipes

## Refactorization
-> Split item/blocks creation from register to items/blocks package
-> Create a base Material class for ease the creation of armors

## Anotations
-> To search for a class in intellij use ctrl+n. This is useful to search for minecraft implementations of stuff

-> Tools
    base = {bonus=1, speed_modifier=4}
    item.bonus = item.bonus + tier.bonus + base.bonus
    item.atk_speed = item.atk_speed + base.atk_speed
    XXXItem(tier, attack_mod, speed_mod, properties)

-> Custom weapons
    Must extend SwordItemClass
    In order to apply different effects during damage calculation must override hurtEnemy(stack, targ, atk) function

-> Armor
    ModArmorMaterialBase(enchantability, duration[], defense[], knockback_res, toughness, name, sound, rep_ingr)
    defense = the number of armor shields
    knockback_res = the value of knockback_res ingame
    toughness = the value of toughness ingame * 0.1
    name must match the textures in /textures/models/armor/<name>_layer_X.png

-> World Generation
    In order to make a vein generate in the overworld we must
        1)  Define the TargetBlocks for sustitution (or a list of them)
        2)  Generate OreConfiguration using the TargetBlocks and a number that is the OreVeinSize
        3)  Generate a ConfiguredFeature using Feature.ORE(OreConfiguration)
        4)  Register the ConfiguredFeature in the configured features registry (note that this is a registry
            from vanilla minecraft) using:

            BuiltinRegistries.register(BuiltinRegistries.CONFIGURED_FEATURE,
                                       new ResourceLocation(configured_feature_name),
                                       ConfiguredFeature)

            Note that this will return another ConfiguredFeature, but this time registered

        5)  Set the placement options using .place(...placements). For example:

            CountPlacement.of(generation_retries),
            BiomeFilter.biome(),
            InSquarePlacement.spread(),
            HeightRangePlacement.uniform(
                    VerticalAnchor.absolute(start_gen_height),
                    VerticalAnchor.absolute(end_gen_height))

            Note that this will return a PlacedFeature that we will need to register again

        6) Use placement features to register the PlacedFeature

            PlacementUtils.register(placed_feature_name, PlacedFeature)

        [*] All previous steps should be wrapped up in a function that allows us to call it from Minecraft Init Events

        7) In a function that is hooked to the forge event bus and to the BiomeLoadingEvent hook our PlacedFeature:

            Hooked to event function:
            IEventBus bus = MinecraftForge.EVENT_BUS;
            bus.addListener(<generation_class>::<generation_event_function>);

            Generation Event Function:
            event.getGeneration().addFeature(GenerationStep.Decoration.UNDERGROUND_ORES, placed_feature);

            Note that we are choosing the GenerationStep of Underground ores

        8) In a function that is hooked to the forge FMLCommonSetupEvent event hook our OreGeneration Function

            event.enqueueWork(ModOreGeneration::registerOres);
